[
    {
        "model": {
            "description": "Simplest, straight forward method to solve a Sudoku with SNNs. Solves a single SNN using a WTA network.",
            "name": "SpikingSudoku"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} SpikingSudoku 0",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "BrainScaleS"
                ]
            },
            {
                "command": "benchmark.py {system} SpikingSudoku 1",
                "name": "Single Chip",
                "target": [
                    "NEST"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "Identical to SpikingSudoku. However, the network structure is defined in a different way, using only a single population and two connectors. Meant to improve speed on spinnaker + GeNN. ",
            "name": "SpikingSudokuSinglePop"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} SpikingSudokuSinglePop 0",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            },
            {
                "command": "benchmark.py {system} SpikingSudokuSinglePop 1",
                "name": "Single Chip",
                "target": [
                    "NEST",
                    "SpiNNaker"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "Similar to SpikingSudoku, but using mirror populations to implement the inhibitory part of the network. This is specifically designed for spikey, which does not allow to have outgoing inh/exc connections at the same time.",
            "name": "SpikingSudokuMirrorInhib"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} SpikingSudokuMirrorInhib 0",
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "Spikey"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "In this benchmark we approximate a function f(x) using a spiking population. X in[0,1] is encoded linearly into a spike frequency, the response is measured. Based on a first evaluation, we have neuron responses for n neurons and m different x values. The resulting matrix is inverted to calculate coefficients for every neuron to approximate the function. A second run looks at the interpolation of the SNN and evaluates deviations from the target function.",
            "name": "FunctionApproximation"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} FunctionApproximation 0",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "This benchmark is dedicated to compare response/activation functions of neurons in neuromorphic hardware to those from simulation. This being said, the simulation from NEST with a numerical timestep of 0.1ms and complex integrator is used as ground truth.",
            "name": "WeightDependentActivation"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} WeightDependentActivation 0",
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "SpiNNaker"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "This benchmark is dedicated to compare response/activation functions of neurons in neuromorphic hardware to those from simulation. This being said, the simulation from NEST with a numerical timestep of 0.1ms and complex integrator is used as ground truth. Specifically, here we use rates as input to neurons",
            "name": "RateBasedWeightDependentActivation"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} RateBasedWeightDependentActivation 0",
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "Spikey"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "Measure the similarity between the rate-based activation curve of a spiking neuron and the ReLU function. ",
            "name": "ReluSimilarity"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} ReluSimilarity 0",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} ReluSimilarity 1",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Chip",
                "target": [
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} ReluSimilarity 2",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Small System",
                "target": [
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            },
            {
                "command": "benchmark.py {system} ReluSimilarity 3",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Large System",
                "target": [
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "This SNAB will test the maximal frequency of a single neuron by simply setting the neuron membrane reset-potential above threshold.",
            "name": "OutputFrequencySingleNeuron"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} OutputFrequencySingleNeuron 0",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "This SNAB will test the maximal frequency of a single neuron by simply setting the neuron membrane reset-potential above threshold. Although, spikes are only recorded for a single neuron, multiple neurons are simulated",
            "name": "OutputFrequencySingleNeuron2"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} OutputFrequencySingleNeuron2 0",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "BrainScaleS"
                ]
            },
            {
                "command": "benchmark.py {system} OutputFrequencySingleNeuron2 1",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Chip",
                "target": [
                    "NEST",
                    "BrainScaleS"
                ]
            },
            {
                "command": "benchmark.py {system} OutputFrequencySingleNeuron2 2",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Small System",
                "target": [
                    "NEST",
                    "BrainScaleS"
                ]
            },
            {
                "command": "benchmark.py {system} OutputFrequencySingleNeuron2 3",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Large System",
                "target": [
                    "BrainScaleS"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "Here we do a similar test as in OutputFrequencySingleNeurons, but now we increase the number of neurons used. We look at averages over neurons instead of the average of a single neuron. This will show possible shortcuts in communication infrastructure of neuron-nhips to the outer world",
            "name": "OutputFrequencyMultipleNeurons"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} OutputFrequencyMultipleNeurons 0",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} OutputFrequencyMultipleNeurons 1",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Chip",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} OutputFrequencyMultipleNeurons 2",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Small System",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            },
            {
                "command": "benchmark.py {system} OutputFrequencyMultipleNeurons 3",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Large System",
                "target": [
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "Check the input bandwidth by injecting spikes per one to one connection. Check if output neurons spike accordingly",
            "name": "MaxInputOneToOne"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} MaxInputOneToOne 0",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} MaxInputOneToOne 1",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Chip",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} MaxInputOneToOne 2",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Small System",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            },
            {
                "command": "benchmark.py {system} MaxInputOneToOne 3",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Large System",
                "target": [
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "Check the input bandwidth by injecting spikes per all to all connection. Check if output neurons spike accordingly",
            "name": "MaxInputAllToAll"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} MaxInputAllToAll 0",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} MaxInputAllToAll 1",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Chip",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} MaxInputAllToAll 2",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Small System",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            },
            {
                "command": "benchmark.py {system} MaxInputAllToAll 3",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Large System",
                "target": [
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "Check the input bandwidth by injecting spikes per fixed fan out connection. Check if output neurons spike accordingly",
            "name": "MaxInputFixedOutConnector"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} MaxInputFixedOutConnector 0",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} MaxInputFixedOutConnector 1",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Chip",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} MaxInputFixedOutConnector 2",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Small System",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            },
            {
                "command": "benchmark.py {system} MaxInputFixedOutConnector 3",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Large System",
                "target": [
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "Check the input bandwidth by injecting spikes per fixed fan out connection. Check if output neurons spike accordingly",
            "name": "MaxInputFixedInConnector"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} MaxInputFixedInConnector 0",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} MaxInputFixedInConnector 1",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Chip",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} MaxInputFixedInConnector 2",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Small System",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            },
            {
                "command": "benchmark.py {system} MaxInputFixedInConnector 3",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Large System",
                "target": [
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "BiNAM: Binary Neural Associative Memory: Uses a pre trained BiNAM and convert it into a spiking network. This requires the fine-tuned target neuron to perform a distinction between e.g. 3 and 4 input spikes and provide a clear threshold function. Easily scalable. If false negatives appear with higher network size this implies reaching a hardware bottleneck.",
            "name": "BiNAM"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} BiNAM 0",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} BiNAM 1",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Chip",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} BiNAM 2",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Small System",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            },
            {
                "command": "benchmark.py {system} BiNAM 3",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Large System",
                "target": [
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "Similar to BiNAM, but uses populations to encode single neurons.",
            "name": "BiNAM_pop"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} BiNAM_pop 0",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} BiNAM_pop 1",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Chip",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} BiNAM_pop 2",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Small System",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            },
            {
                "command": "benchmark.py {system} BiNAM_pop 3",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Large System",
                "target": [
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "Similar to BiNAM, but uses a burst of spikes to encode a set bit.",
            "name": "BiNAM_burst"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} BiNAM_burst 0",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} BiNAM_burst 1",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Chip",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} BiNAM_burst 2",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Small System",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            },
            {
                "command": "benchmark.py {system} BiNAM_burst 3",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Large System",
                "target": [
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "Similar to BiNAM, but uses a burst of spikes to encode a set bit and a population to encode single neurons. Thus, it is a combination of two methods described before.",
            "name": "BiNAM_pop_burst"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} BiNAM_pop_burst 0",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} BiNAM_pop_burst 1",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Chip",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} BiNAM_pop_burst 2",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Small System",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            },
            {
                "command": "benchmark.py {system} BiNAM_pop_burst 3",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Large System",
                "target": [
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "The aim of this SNAB is to measure the bandwidth between neuron populations. Therefore, taking parameters from the OutputFrequency benchmarks, a single continously spiking neuron is connected to a population of neurons. The number of spikes of the population is measured and taken as the benchmark measure. ",
            "name": "SingleMaxFreqToGroup"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} SingleMaxFreqToGroup 0",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} SingleMaxFreqToGroup 1",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Chip",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} SingleMaxFreqToGroup 2",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Small System",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            },
            {
                "command": "benchmark.py {system} SingleMaxFreqToGroup 3",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Large System",
                "target": [
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "Similar to the benchmark before, this SNAB measures the bandwidth between neuron populations. Now, the input population firing at maximal frequency consist of the same number of neurons as the target population. The populations are connected via a OneToOne-Connector.",
            "name": "GroupMaxFreqToGroup"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} GroupMaxFreqToGroup 0",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} GroupMaxFreqToGroup 1",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Chip",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} GroupMaxFreqToGroup 2",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Small System",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            },
            {
                "command": "benchmark.py {system} GroupMaxFreqToGroup 3",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Large System",
                "target": [
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "Identical to GroupMaxFreqToGroup, but using the AllToAll connector and allowing different number of input neurons",
            "name": "GroupMaxFreqToGroupAllToAll"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} GroupMaxFreqToGroupAllToAll 0",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} GroupMaxFreqToGroupAllToAll 1",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Chip",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            },
            {
                "command": "benchmark.py {system} GroupMaxFreqToGroupAllToAll 2",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Small System",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            },
            {
                "command": "benchmark.py {system} GroupMaxFreqToGroupAllToAll 3",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Large System",
                "target": [
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "Identical to GroupMaxFreqToGroup, but using the FixedProbability connector and allowing different number of input neurons",
            "name": "GroupMaxFreqToGroupProb"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} GroupMaxFreqToGroupProb 0",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} GroupMaxFreqToGroupProb 1",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Chip",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} GroupMaxFreqToGroupProb 2",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Small System",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            },
            {
                "command": "benchmark.py {system} GroupMaxFreqToGroupProb 3",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Large System",
                "target": [
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "This benchmark measures the setup time with a OneToOne Connector and compares the speedup to the same connection using a FromList connector",
            "name": "SetupTimeOneToOne"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} SetupTimeOneToOne 0",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} SetupTimeOneToOne 1",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Chip",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} SetupTimeOneToOne 2",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Small System",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            },
            {
                "command": "benchmark.py {system} SetupTimeOneToOne 3",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Large System",
                "target": [
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "This benchmark measures the setup time with a AllToAll Connector and compares the speedup to the same connection using a FromList connector",
            "name": "SetupTimeAllToAll"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} SetupTimeAllToAll 0",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} SetupTimeAllToAll 1",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Chip",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} SetupTimeAllToAll 2",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Small System",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            },
            {
                "command": "benchmark.py {system} SetupTimeAllToAll 3",
                "name": "Large System",
                "target": [
                    "SpiNNaker"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "This benchmark measures the setup time with a Random Connector and compares the speedup to the same connection using a FromList connector",
            "name": "SetupTimeRandom"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} SetupTimeRandom 0",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} SetupTimeRandom 1",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Chip",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} SetupTimeRandom 2",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Small System",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            },
            {
                "command": "benchmark.py {system} SetupTimeRandom 3",
                "name": "Large System",
                "target": [
                    "SpiNNaker"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "This SNAB looks at the voltage trace of a single neuron to measure the length of the refractory period. The result is the deviation from the set parameter: Negative values correspond to too short periods, positive values indicate a period which is too long.",
            "name": "RefractoryPeriod"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} RefractoryPeriod 0",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "SimpleWTA: A simple Winner-Takes-All network. Every population represents a winner, inhibition is directly between the populations.",
            "name": "SimpleWTA"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} SimpleWTA 0",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "Lateral Inhibition Winner-Takes-All: A centered inhibitory population suppresses all Winner populations.",
            "name": "LateralInhibWTA"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} LateralInhibWTA 0",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "All Winner populations are mirrored by an inhibitory population, which suppresses all other (besides their own) winner population.",
            "name": "MirrorInhibWTA"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} MirrorInhibWTA 0",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "Similar to MirrorInhibWTA, but focuses on using smaller populations. ",
            "name": "MirrorInhibWTASmall"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} MirrorInhibWTASmall 0",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "Implements the mapping part of Simultaneous Localization and Mapping: a 2D robot navigates in a virtual environment. A bumper sensor is triggered whenever the robot touches a wall or obstacle. The internal map of the surrounding is built using STDP.",
            "name": "SpikingSlam"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} SpikingSlam 0",
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "SpiNNaker"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "A simple feed-forward network with densely connected layers. This network has 89x100x10 layout with images downscales by 3x3 average pooling and no inhibition",
            "name": "MnistSpikey"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} MnistSpikey 0",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "BrainScaleS",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} MnistSpikey 1",
                "name": "Single Chip",
                "target": [
                    "NEST",
                    "SpiNNaker"
                ]
            },
            {
                "command": "benchmark.py {system} MnistSpikey 2",
                "name": "Small System",
                "target": [
                    "NEST",
                    "SpiNNaker"
                ]
            },
            {
                "command": "benchmark.py {system} MnistSpikey 3",
                "name": "Large System",
                "target": [
                    "NEST",
                    "SpiNNaker"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "A simple feed-forward network with densely connected layers. This is a network optimized by Neural Architecture Search. Layout: 784x43x10x10",
            "name": "MnistNAS63"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} MnistNAS63 0",
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "SpiNNaker"
                ]
            },
            {
                "command": "benchmark.py {system} MnistNAS63 1",
                "name": "Single Chip",
                "target": [
                    "NEST",
                    "SpiNNaker"
                ]
            },
            {
                "command": "benchmark.py {system} MnistNAS63 2",
                "name": "Small System",
                "target": [
                    "NEST",
                    "SpiNNaker"
                ]
            },
            {
                "command": "benchmark.py {system} MnistNAS63 3",
                "name": "Large System",
                "target": [
                    "NEST",
                    "SpiNNaker"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "A simple feed-forward network with densely connected layers. This is a network optimized by Neural Architecture Search. Layout: 784x52x35x32x10",
            "name": "MnistNAS129"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} MnistNAS129 0",
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "SpiNNaker"
                ]
            },
            {
                "command": "benchmark.py {system} MnistNAS129 1",
                "name": "Single Chip",
                "target": [
                    "NEST",
                    "SpiNNaker"
                ]
            },
            {
                "command": "benchmark.py {system} MnistNAS129 2",
                "name": "Small System",
                "target": [
                    "NEST",
                    "SpiNNaker"
                ]
            },
            {
                "command": "benchmark.py {system} MnistNAS129 3",
                "name": "Large System",
                "target": [
                    "NEST",
                    "SpiNNaker"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "A simple feed-forward network with densely connected layers. This is a network optimized by Neural Architecture Search. Layout: 784x866x52x35x32x10",
            "name": "MnistNAStop"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} MnistNAStop 0",
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "SpiNNaker"
                ]
            },
            {
                "command": "benchmark.py {system} MnistNAStop 1",
                "name": "Single Chip",
                "target": [
                    "NEST",
                    "SpiNNaker"
                ]
            },
            {
                "command": "benchmark.py {system} MnistNAStop 2",
                "name": "Small System",
                "target": [
                    "NEST",
                    "SpiNNaker"
                ]
            },
            {
                "command": "benchmark.py {system} MnistNAStop 3",
                "name": "Large System",
                "target": [
                    "NEST",
                    "SpiNNaker"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "A simple feed-forward network with densely connected layers. This is a network taken from https://github.com/dannyneil/spiking_relu_conversion Corresponding paper: Diehl et al.: M. Fast-Classifying, High-Accuracy Spiking Deep Networks Through Weight and Threshold Balancing. Layout: 784x1200x1200x10",
            "name": "MnistDiehl"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} MnistDiehl 0",
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST"
                ]
            },
            {
                "command": "benchmark.py {system} MnistDiehl 1",
                "name": "Single Chip",
                "target": [
                    "NEST"
                ]
            },
            {
                "command": "benchmark.py {system} MnistDiehl 2",
                "name": "Small System",
                "target": [
                    "NEST"
                ]
            },
            {
                "command": "benchmark.py {system} MnistDiehl 3",
                "name": "Large System",
                "target": [
                    "NEST"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "This class combines the MNIST benchmark with an hardware in the loop re-training to compensate device mismatch. Here, we train all layers",
            "name": "MnistITL"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} MnistITL 0",
                "config": {
                    "BrainScaleS": {
                        "WAFER_MODULE": 33
                    }
                },
                "name": "Single Core/Smallest Network",
                "target": [
                    "BrainScaleS",
                    "Spikey"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "A simple feed-forward network with densely connected layers. This network has 89x100x10 layout with images downscales by 3x3 average pooling and no inhibition In contrast to MnistSpikey, use TTFS encoding",
            "name": "MnistSpikeyTTFS"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} MnistSpikeyTTFS 0",
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST",
                    "SpiNNaker",
                    "Spikey"
                ]
            },
            {
                "command": "benchmark.py {system} MnistSpikeyTTFS 1",
                "name": "Single Chip",
                "target": [
                    "NEST",
                    "SpiNNaker"
                ]
            },
            {
                "command": "benchmark.py {system} MnistSpikeyTTFS 2",
                "name": "Small System",
                "target": [
                    "NEST",
                    "SpiNNaker"
                ]
            },
            {
                "command": "benchmark.py {system} MnistSpikeyTTFS 3",
                "name": "Large System",
                "target": [
                    "NEST",
                    "SpiNNaker"
                ]
            }
        ]
    },
    {
        "model": {
            "description": "A simple feed-forward network with densely connected layers. This is a network taken from https://github.com/dannyneil/spiking_relu_conversion Corresponding paper: Diehl et al.: M. Fast-Classifying, High-Accuracy Spiking Deep Networks Through Weight and Threshold Balancing. Layout: 784x1200x1200x10 In contrast to MnistDiehl, use TTFS encoding",
            "name": "MnistDiehlTTFS"
        },
        "tasks": [
            {
                "command": "benchmark.py {system} MnistDiehlTTFS 0",
                "name": "Single Core/Smallest Network",
                "target": [
                    "NEST"
                ]
            },
            {
                "command": "benchmark.py {system} MnistDiehlTTFS 1",
                "name": "Single Chip",
                "target": [
                    "NEST"
                ]
            },
            {
                "command": "benchmark.py {system} MnistDiehlTTFS 2",
                "name": "Small System",
                "target": [
                    "NEST"
                ]
            }
        ]
    }
]